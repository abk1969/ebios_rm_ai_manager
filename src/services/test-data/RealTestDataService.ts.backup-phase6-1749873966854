/**
 * üéØ SERVICE DE DONN√âES DE TEST R√âELLES
 * G√©n√®re et g√®re des donn√©es r√©elles pour les tests EBIOS RM
 */

import { collection, addDoc, getDocs, deleteDoc, doc, writeBatch } from 'firebase/firestore';
import { testDb } from '@/config/firebase.test';

export interface TestMission {
  id?: string;
  name: string;
  description: string;
  organization: string;
  scope: string;
  status: 'draft' | 'in-progress' | 'completed' | 'archived';
  createdAt: string;
  updatedAt: string;
  metadata: {
    version: string;
    methodology: 'EBIOS-RM';
    compliance: string[];
  };
}

export interface TestBusinessValue {
  id?: string;
  missionId: string;
  name: string;
  description: string;
  category: 'data' | 'service' | 'process' | 'reputation';
  criticalityLevel: 1 | 2 | 3 | 4;
  impactTypes: string[];
  stakeholders: string[];
  dependencies: string[];
  createdAt: string;
}

export interface TestSupportingAsset {
  id?: string;
  missionId: string;
  name: string;
  description: string;
  type: 'physical' | 'logical' | 'human' | 'organizational';
  category: string;
  location: string;
  owner: string;
  securityLevel: 'public' | 'internal' | 'confidential' | 'secret';
  businessValues: string[];
  createdAt: string;
}

export interface TestDreadedEvent {
  id?: string;
  missionId: string;
  name: string;
  description: string;
  impactedBusinessValues: string[];
  impactLevel: 1 | 2 | 3 | 4;
  impactTypes: {
    availability: number;
    integrity: number;
    confidentiality: number;
    authenticity: number;
  };
  consequences: string[];
  createdAt: string;
}

/**
 * Service de gestion des donn√©es de test r√©elles
 */
export class RealTestDataService {
  private static instance: RealTestDataService;

  public static getInstance(): RealTestDataService {
    if (!RealTestDataService.instance) {
      RealTestDataService.instance = new RealTestDataService();
    }
    return RealTestDataService.instance;
  }

  /**
   * Cr√©e une mission de test compl√®te avec toutes ses donn√©es
   */
  async createTestMission(missionName: string = 'Mission Test EBIOS RM'): Promise<string> {
    // console.log supprim√©;

    // 1. Cr√©er la mission
    const mission: TestMission = {
      name: missionName,
      description: 'Mission de test pour validation des m√©triques EBIOS RM avec donn√©es r√©elles',
      organization: 'Organisation Test ANSSI',
      scope: 'Syst√®me d\'information critique de test',
      status: 'in-progress',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      metadata: {
        version: '1.0.0',
        methodology: 'EBIOS-RM',
        compliance: ['ANSSI', 'ISO27001', 'NIST']
      }
    };

    const missionRef = await addDoc(collection(testDb, 'missions'), mission);
    const missionId = missionRef.id;
    console.log(`‚úÖ Mission cr√©√©e avec ID: ${missionId}`);

    // 2. Cr√©er les biens essentiels (minimum ANSSI: 3)
    await this.createBusinessValues(missionId);

    // 3. Cr√©er les biens supports (minimum ANSSI: 5)
    await this.createSupportingAssets(missionId);

    // 4. Cr√©er les √©v√©nements redout√©s (minimum ANSSI: 2)
    await this.createDreadedEvents(missionId);

    // 5. Cr√©er les sources de risque
    await this.createRiskSources(missionId);

    // 6. Cr√©er les sc√©narios strat√©giques
    await this.createStrategicScenarios(missionId);

    // 7. Cr√©er les sc√©narios op√©rationnels
    await this.createOperationalScenarios(missionId);

    // 8. Cr√©er les mesures de s√©curit√©
    await this.createSecurityMeasures(missionId);

    // console.log supprim√©;
    return missionId;
  }

  /**
   * Cr√©e des biens essentiels r√©alistes
   */
  private async createBusinessValues(missionId: string): Promise<void> {
    const businessValues: TestBusinessValue[] = [
      {
        missionId,
        name: 'Donn√©es clients sensibles',
        description: 'Base de donn√©es contenant les informations personnelles et financi√®res des clients',
        category: 'data',
        criticalityLevel: 4,
        impactTypes: ['confidentialit√©', 'int√©grit√©', 'disponibilit√©'],
        stakeholders: ['Direction', 'RSSI', 'DPO'],
        dependencies: ['Syst√®me de sauvegarde', 'Chiffrement'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Service de paiement en ligne',
        description: 'Plateforme de traitement des transactions financi√®res',
        category: 'service',
        criticalityLevel: 4,
        impactTypes: ['disponibilit√©', 'int√©grit√©', 'authentification'],
        stakeholders: ['Direction commerciale', 'DSI', 'Compliance'],
        dependencies: ['HSM', 'R√©seau bancaire'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Processus de validation KYC',
        description: 'Processus de v√©rification d\'identit√© et de conformit√© r√©glementaire',
        category: 'process',
        criticalityLevel: 3,
        impactTypes: ['int√©grit√©', 'tra√ßabilit√©', 'conformit√©'],
        stakeholders: ['Compliance', 'Juridique', 'Op√©rations'],
        dependencies: ['Syst√®me documentaire', 'API externes'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'R√©putation de l\'organisation',
        description: 'Image de marque et confiance des parties prenantes',
        category: 'reputation',
        criticalityLevel: 3,
        impactTypes: ['image', 'confiance', 'business'],
        stakeholders: ['Direction g√©n√©rale', 'Communication', 'Marketing'],
        dependencies: ['M√©dias', 'R√©seaux sociaux', 'Clients'],
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    businessValues.forEach(bv => {
      const ref = doc(collection(testDb, 'businessValues'));
      batch.set(ref, bv);
    });
    await batch.commit();
    console.log(`‚úÖ ${businessValues.length} biens essentiels cr√©√©s`);
  }

  /**
   * Cr√©e des biens supports r√©alistes
   */
  private async createSupportingAssets(missionId: string): Promise<void> {
    const supportingAssets: TestSupportingAsset[] = [
      {
        missionId,
        name: 'Serveur de base de donn√©es principal',
        description: 'Serveur h√©bergeant la base de donn√©es clients en production',
        type: 'physical',
        category: 'infrastructure',
        location: 'Datacenter principal - Rack A12',
        owner: 'DSI',
        securityLevel: 'secret',
        businessValues: ['Donn√©es clients sensibles'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Application web de paiement',
        description: 'Interface utilisateur pour les transactions en ligne',
        type: 'logical',
        category: 'application',
        location: 'Cloud AWS - eu-west-1',
        owner: '√âquipe d√©veloppement',
        securityLevel: 'confidential',
        businessValues: ['Service de paiement en ligne'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: '√âquipe support client',
        description: 'Personnel en charge de l\'assistance client√®le',
        type: 'human',
        category: 'personnel',
        location: 'Si√®ge social - √âtage 3',
        owner: 'RH',
        securityLevel: 'internal',
        businessValues: ['Service de paiement en ligne', 'R√©putation de l\'organisation'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Proc√©dure de validation KYC',
        description: 'Documentation et processus de v√©rification d\'identit√©',
        type: 'organizational',
        category: 'processus',
        location: 'Syst√®me documentaire',
        owner: 'Compliance',
        securityLevel: 'confidential',
        businessValues: ['Processus de validation KYC'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'R√©seau interne s√©curis√©',
        description: 'Infrastructure r√©seau de l\'organisation',
        type: 'logical',
        category: 'r√©seau',
        location: 'P√©rim√®tre organisationnel',
        owner: 'DSI',
        securityLevel: 'secret',
        businessValues: ['Donn√©es clients sensibles', 'Service de paiement en ligne'],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Syst√®me de sauvegarde',
        description: 'Infrastructure de sauvegarde et de r√©cup√©ration',
        type: 'physical',
        category: 'infrastructure',
        location: 'Datacenter secondaire',
        owner: 'DSI',
        securityLevel: 'secret',
        businessValues: ['Donn√©es clients sensibles'],
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    supportingAssets.forEach(sa => {
      const ref = doc(collection(testDb, 'supportingAssets'));
      batch.set(ref, sa);
    });
    await batch.commit();
    console.log(`‚úÖ ${supportingAssets.length} biens supports cr√©√©s`);
  }

  /**
   * Cr√©e des √©v√©nements redout√©s r√©alistes
   */
  private async createDreadedEvents(missionId: string): Promise<void> {
    const dreadedEvents: TestDreadedEvent[] = [
      {
        missionId,
        name: 'Fuite de donn√©es clients',
        description: 'Divulgation non autoris√©e des donn√©es personnelles et financi√®res',
        impactedBusinessValues: ['Donn√©es clients sensibles', 'R√©putation de l\'organisation'],
        impactLevel: 4,
        impactTypes: {
          availability: 2,
          integrity: 3,
          confidentiality: 4,
          authenticity: 2
        },
        consequences: [
          'Sanctions RGPD',
          'Perte de confiance clients',
          'Impact financier majeur',
          'Dommage r√©putationnel'
        ],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Indisponibilit√© du service de paiement',
        description: 'Interruption prolong√©e du syst√®me de paiement en ligne',
        impactedBusinessValues: ['Service de paiement en ligne', 'R√©putation de l\'organisation'],
        impactLevel: 3,
        impactTypes: {
          availability: 4,
          integrity: 2,
          confidentiality: 1,
          authenticity: 2
        },
        consequences: [
          'Perte de chiffre d\'affaires',
          'Insatisfaction clients',
          'P√©nalit√©s contractuelles',
          'Co√ªts de r√©cup√©ration'
        ],
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Corruption des donn√©es de validation KYC',
        description: 'Alt√©ration des donn√©es de v√©rification d\'identit√©',
        impactedBusinessValues: ['Processus de validation KYC'],
        impactLevel: 3,
        impactTypes: {
          availability: 2,
          integrity: 4,
          confidentiality: 2,
          authenticity: 3
        },
        consequences: [
          'Non-conformit√© r√©glementaire',
          'Sanctions autorit√©s',
          'Risque de blanchiment',
          'Audit externe'
        ],
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    dreadedEvents.forEach(de => {
      const ref = doc(collection(testDb, 'dreadedEvents'));
      batch.set(ref, de);
    });
    await batch.commit();
    console.log(`‚úÖ ${dreadedEvents.length} √©v√©nements redout√©s cr√©√©s`);
  }

  /**
   * Cr√©e des sources de risque r√©alistes
   */
  private async createRiskSources(missionId: string): Promise<void> {
    const riskSources = [
      {
        missionId,
        name: 'Cybercriminels organis√©s',
        description: 'Groupes criminels sp√©cialis√©s dans le vol de donn√©es financi√®res',
        category: 'externe',
        motivation: 'financi√®re',
        capabilities: ['hacking avanc√©', 'ing√©nierie sociale', 'malware'],
        resources: '√©lev√©es',
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Employ√© malveillant',
        description: 'Personnel interne avec acc√®s privil√©gi√©',
        category: 'interne',
        motivation: 'vengeance',
        capabilities: ['acc√®s l√©gitime', 'connaissance syst√®me'],
        resources: 'moyennes',
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    riskSources.forEach(rs => {
      const ref = doc(collection(testDb, 'riskSources'));
      batch.set(ref, rs);
    });
    await batch.commit();
    console.log(`‚úÖ ${riskSources.length} sources de risque cr√©√©es`);
  }

  /**
   * Cr√©e des sc√©narios strat√©giques
   */
  private async createStrategicScenarios(missionId: string): Promise<void> {
    const scenarios = [
      {
        missionId,
        name: 'Attaque cibl√©e sur les donn√©es clients',
        description: 'Sc√©nario d\'exfiltration de donn√©es par cybercriminels',
        riskSource: 'Cybercriminels organis√©s',
        targetedAssets: ['Serveur de base de donn√©es principal'],
        attackPath: 'Phishing -> Escalade privil√®ges -> Exfiltration',
        likelihood: 3,
        impact: 4,
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    scenarios.forEach(s => {
      const ref = doc(collection(testDb, 'strategicScenarios'));
      batch.set(ref, s);
    });
    await batch.commit();
    console.log(`‚úÖ ${scenarios.length} sc√©narios strat√©giques cr√©√©s`);
  }

  /**
   * Cr√©e des sc√©narios op√©rationnels
   */
  private async createOperationalScenarios(missionId: string): Promise<void> {
    const scenarios = [
      {
        missionId,
        name: 'Exploitation vuln√©rabilit√© SQL injection',
        description: 'Sc√©nario d√©taill√© d\'exploitation de faille applicative',
        strategicScenario: 'Attaque cibl√©e sur les donn√©es clients',
        technicalSteps: ['Reconnaissance', 'Injection SQL', 'Extraction donn√©es'],
        likelihood: 2,
        impact: 4,
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    scenarios.forEach(s => {
      const ref = doc(collection(testDb, 'operationalScenarios'));
      batch.set(ref, s);
    });
    await batch.commit();
    console.log(`‚úÖ ${scenarios.length} sc√©narios op√©rationnels cr√©√©s`);
  }

  /**
   * Cr√©e des mesures de s√©curit√©
   */
  private async createSecurityMeasures(missionId: string): Promise<void> {
    const measures = [
      {
        missionId,
        name: 'Chiffrement base de donn√©es',
        description: 'Chiffrement AES-256 des donn√©es sensibles',
        type: 'technique',
        category: 'protection',
        status: 'implemented',
        effectiveness: 4,
        cost: 3,
        createdAt: new Date().toISOString()
      },
      {
        missionId,
        name: 'Formation s√©curit√© personnel',
        description: 'Programme de sensibilisation aux risques cyber',
        type: 'organisationnel',
        category: 'pr√©vention',
        status: 'planned',
        effectiveness: 3,
        cost: 2,
        createdAt: new Date().toISOString()
      }
    ];

    const batch = writeBatch(testDb);
    measures.forEach(m => {
      const ref = doc(collection(testDb, 'securityMeasures'));
      batch.set(ref, m);
    });
    await batch.commit();
    console.log(`‚úÖ ${measures.length} mesures de s√©curit√© cr√©√©es`);
  }

  /**
   * Supprime toutes les donn√©es de test d'une mission
   */
  async deleteTestMission(missionId: string): Promise<void> {
    // console.log supprim√©;

    const collections = [
      'missions',
      'businessValues',
      'supportingAssets',
      'dreadedEvents',
      'riskSources',
      'strategicScenarios',
      'operationalScenarios',
      'securityMeasures'
    ];

    for (const collectionName of collections) {
      const snapshot = await getDocs(collection(testDb, collectionName));
      const batch = writeBatch(testDb);
      
      snapshot.docs.forEach(docSnapshot => {
        const data = docSnapshot.data();
        if (data.missionId === missionId || docSnapshot.id === missionId) {
          batch.delete(docSnapshot.ref);
        }
      });
      
      await batch.commit();
    }

    // console.log supprim√©;
  }

  /**
   * Nettoie toutes les donn√©es de test
   */
  async cleanupAllTestData(): Promise<void> {
    // console.log supprim√©;

    const collections = [
      'missions',
      'businessValues',
      'supportingAssets',
      'dreadedEvents',
      'riskSources',
      'strategicScenarios',
      'operationalScenarios',
      'securityMeasures'
    ];

    for (const collectionName of collections) {
      const snapshot = await getDocs(collection(testDb, collectionName));
      const batch = writeBatch(testDb);
      
      snapshot.docs.forEach(docSnapshot => {
        batch.delete(docSnapshot.ref);
      });
      
      if (snapshot.docs.length > 0) {
        await batch.commit();
        console.log(`‚úÖ ${snapshot.docs.length} documents supprim√©s de ${collectionName}`);
      }
    }

    console.log('‚úÖ Nettoyage complet termin√©');
  }
}

export default RealTestDataService;
